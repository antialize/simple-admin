use anyhow::{Context, Result, bail};
use clap::Parser;
use sadmin2::{action_types, page_types, type_types};
use std::{collections::HashSet, io::Write};
use ts_rs::TS;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    #[arg(long)]
    validate: bool,
}

pub fn main() -> Result<()> {
    let args = Args::parse();

    let mut exports = vec![serde_json::Value::export_to_string().unwrap()];
    exports.push("export type JsonMap = { [key in string]?: JsonValue };".to_string());
    exports.extend(page_types::export_ts());
    exports.extend(type_types::export_ts());
    exports.extend(action_types::export_ts());

    let mut imported = HashSet::new();
    let mut exported = HashSet::new();
    let mut output = String::new();
    output.push_str("// Generated by export_ts, DO NOT EDIT\n\n");
    for v in &exports {
        for line in v.lines() {
            if line.starts_with("//") {
                continue;
            }
            if line.is_empty() {
                continue;
            }
            if let Some(line) = line.strip_prefix("import type { ") {
                let (imp, _) = line.split_once(" }").context("Bad import type line")?;
                imported.insert(imp);
                continue;
            }
            if let Some(l) = line.strip_prefix("export type ") {
                let (exp, _) = l.split_once(" =").context("Bad export type line")?;
                let exp = exp.strip_suffix("<T>").unwrap_or(exp);
                exported.insert(exp);
                let line = line
                    .replace(" bigint", " number")
                    .replace("<bigint", "<number")
                    .replace("[bigint", "[number")
                    .replace("= Record<string, never>", "= Record<string, unknown>");
                output.push_str(&line);
                output.push_str("\n\n");
                continue;
            }
            if line.starts_with("export enum") || line.starts_with("export const") {
                output.push_str(line);
                output.push_str("\n\n");
                continue;
            }
            bail!("Unknown line {}", line);
        }
    }

    let p = "frontend/src/shared_types.ts";

    let mut cmd = std::process::Command::new("./frontend/node_modules/.bin/biome")
        .arg("format")
        .arg("--stdin-file-path")
        .arg(p)
        .arg("--config-path")
        .arg("frontend/biome.jsonc")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()?;

    let mut stdin = cmd.stdin.take().context("Missing stdin")?;
    std::thread::spawn(move || {
        stdin.write_all(output.as_bytes()).unwrap();
        std::mem::drop(stdin);
    });

    let output = cmd.wait_with_output()?;
    if !output.status.success() {
        bail!("Command failed {:?}", output.status)
    };
    let new_actions = output.stdout;

    let actions = std::fs::read(p).with_context(|| format!("Failed reading {p}"))?;
    if actions != new_actions {
        if args.validate {
            bail!("{} is not up to date", p);
        } else {
            println!("{p} generated");
            std::fs::write(p, &new_actions).with_context(|| format!("Failed writing {p}"))?
        }
    } else {
        println!("{p} is up to date");
    }
    Ok(())
}
